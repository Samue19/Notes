# 浏览器

浏览器是多进程架构：

+ **浏览器主进程**。只有⼀个，控制页⾯的创建、销毁、⽹络资源管理、下载等, 同时提供存储等功能 。
+ **第三方插件进程**。每⼀种类型的插件对应⼀个进程，仅当使⽤该插件时才创建。 主要是负责插件的运⾏，因 插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页⾯造成 影响.
+ **GPU进程**。 最多⼀个，⽤于3D绘制等,从浏览器进程中独⽴出来的。
+ **浏览器渲染进程(浏览器内核)**。 每个Tab页对应⼀个进程，互不影响 , 核⼼任务是将HTML、CSS 和 JavaScript转换为可以 与⽤户交互的⽹页。 出于安全考虑，渲染进程都是运⾏在沙箱模式下。
+ **⽹络进程**。 从浏览器进程中独⽴出来的, 主要负责页⾯的⽹络资源加载。
+ **GUI 线程**。 负责渲染页⾯，解析 html、css；构建 DOM 树和渲染树；当界⾯需要重绘(Repaint)或由于 某种操作引发回流(reflow)时,该线程就会执⾏。在Javascript引擎运⾏脚本期间,GUI渲染线 程都是处于挂起状态的,也就是说被”冻结”了.
+ **js 引擎线程**。 负责解析和执⾏ js 程序，我们经常听到的 chrome 的 v8 引擎就是跑在 js 引擎线程上的，其 实语⾔没有单线程多线程之说，因为解释这个语⾔的是 的线程是单线程；js 引擎线程与 gui 线程互斥，当浏览器执⾏ javaScript 程序的时候，GUI 渲染线层会保存在⼀个队列当中；直 到 js 程序执⾏完成，才会接着执⾏；如果 js 的执⾏时间过长，会影响页⾯的渲染不连贯， 所有我们要尽量控制 js 的⼤⼩
+ **定时触发线程**。 浏览器定时计数器并不是由JS引擎计数的, 因为JS引擎是单线程的, 如果处于阻塞线程状态就 会影响记计时的准确, 因此通过单独线程来计时并触发定时是更为合理的⽅案。 为什么 setTimeout 不阻塞后⾯程序的运⾏，因为 setTimeout 不是由 js 引擎线程完成的， 是由定时器触发线程完成的，所以它们可以同时进⾏，那么定时器触发线程在这定时任务完 成之后会通知事件触发线程往任务队列⾥添加事件。
+ **事件触发线程**。 当⼀个事件被触发时该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理。这些事 件可以是当前执⾏的代码块如定时任务、也可来⾃浏览器内核的其他线程如⿏标点击、 AJAX异步请求等，但由于JS的单线程关系所有这些事件都得排队等待JS引擎处理。
+ **异步 HTTP 请求线程**。 在XMLHttpRequest在连接后是通过浏览器新开⼀个线程请求， 将检测到状态变更时，如果 设置有回调函数，异步线程就产⽣状态变更事件放到 JavaScript引擎的处理队列中等待处 理。

优点：进程（页面）相互隔离，沙箱模式

异步场景 

 	1. 定时器 
 	2.  ⽹络请求 
 	3.  事件绑定 
 	4.  ES6 Promise 定时器 

执⾏调⽤栈的代码，栈中为空时去检查任务队列，这是⼀个循环检查的过程，等到事件触发 线程往任务队列中添加了定时器事件，这时再去检查已经有了定时器的异步任务，取出放进 执⾏栈执⾏。 带来问题 定时任务可能不会按时执⾏。

 应⽤场景 

1. 防抖节流 
2. 倒计时 
3. 动画(丢帧问题)

内核 

浏览器内核是通过取得页⾯内容、整理信息、计算和组合最终输出可视化图像结果（渲染引 擎） 每⼀个tab页⾯可以看作是浏览器内核进程，浏览器内核是多线程的。 

常见浏览器内核 

Trident内核：IE，360，搜狗等浏览器 

Gecko内核：Netscape6及以上版本，Firefox 

Blink内核：Opera7及以上 

Webkit内核：Safari，Chrome 

检测版本 

1. 检测 window.navigator.userAgent 的值，但这种⽅式很不可靠，因为 userAgent可 以被改写，并且早期的浏览器如 ie，会通过伪装⾃⼰的 userAgent的值为 Mozilla 来躲过服务器的检测。 
2. 功能检测，根据每个浏览器独有的特性来进⾏判断，如 ie 下独有的 ActiveXObject。



### 事件循环

1. Event Loop 

​		Js引擎在执⾏代码时候会产⽣执⾏栈，当调⽤异步 API，例如 setTimeout， setInterval，Promise 等回调触发时，就会进⼊异步任务队列，当同步代码执⾏完成 后，就会去异步队列取出回调函数并执⾏，这样就形成了⼀个事件循环。在 Javascript 中有两种任务类型，分别是 宏任务 和 微任务 。 

事件循环唯⼀任务：将队列和调⽤堆栈连接起来。 

事件队列是⼀个存储执⾏任务的队列。 

执⾏栈类似于函数调⽤栈的运⾏容器，当其为空时，JS检查事件队列，将第⼀个任务压⼊栈 中执⾏。若调⽤栈和微任务队列为空，事件循环检查宏任务队列是否还有任务，从中弹出进 ⼊调⽤栈执⾏完再弹出。 

+ setTimeout的时间不是指马上执⾏，⽽是最快可以多久后执⾏，因为它会等待调 ⽤ 栈为空时执⾏。
+ 浏览器的渲染必须要调⽤栈为空时才会执⾏，正常的 forEach 会阻塞渲染。 
+ 在⼀个回调出栈，另⼀个回调进栈的间隙(此时栈空)，渲染得以顺利进⾏。

单线程JS实现异步 

浏览器的内核多线程实现。

 script是宏任务 

​		若存在两个script代码块，⾸先执⾏第⼀个 script 中的同步代码，若这个过程中创建了微任 务并进⼊了微任务队列，第⼀个 script 同步代码执⾏完之后，⾸先清空微任务队列，再去 开启第⼆个 script 的执⾏。 

js单线程问题 

​		所有任务都在⼀个线程上完成，⼀旦遇到⼤量任务或遇到⼀个耗时的任务，⽹页就可能出现 卡死，也⽆法响应⽤户的⾏为。 

setTimeout如果在主线程上运⾏就会阻塞其他活动。 所以，需要做的就是，离开这个线程，同时运⾏这个任务。 

JavaScript的单线程，与它的⽤途有关。 

作为浏览器脚本语⾔，JavaScript的主要⽤途是与⽤户互动，以及操作DOM。这决定了它只 能是单线程，否则会带来很复杂的同步问题。 ⽐如，假定JavaScript同时有两个线程，⼀个线程在某个DOM节点上添加内容，另⼀个线程 删除了这个节点，这时浏览器应该以哪个线程为准？ 所以，为了避免复杂性，从⼀诞⽣，JavaScript就是单线程，这已经成了这门语⾔的核⼼特 征，将来也不会改变。 

Event Loop 

是⼀个程序结构，⽤户等待和发送信息的事件。 简单说就是在程序中设置 2 个线程，⼀个负责程序本⾝的运⾏，称为“主线程”；另⼀个负责 主线程和其他进程（主要是各种 I/O 操作）的通信 被称为“Event Loop 线程”（也可以翻译 为消息线层） js 就是采⽤了这种机制，来解决单线程带来的问题。 

浏览器的 Event Loop 

microtask在事件循环的macrotask执⾏完之后执⾏。 

macro（宏任务）有多个，微任务（micro）队列只有⼀个。 

先执⾏宏任务，再执⾏微任务，执⾏宏任务的过程中遇到微任务，依次加⼊微任务队列。 

异步实现 

1. 宏观：浏览器多线程（从宏观来看是多线程实现了异步） 
2. 微观：Event Loop，事件循环（Event Loop 翻译是事件循环，是实现异步的⼀种 机制） 

常见的macrotask有：(⼀般由浏览器发起)DOM渲染后触发 

1. script整体代码 
2. setImmediate：node 的⽅法 
3. setTimeout 和 setInterval 
4. requestAnimationFrame 
5. I/O 
6. UI rendering 

常见的microtask有：(⼀般由JS⾃⾝创建)DOM渲染前触发 

1. process.nextTick (Node环境中) 
2. Promise callback(例如 promise.then) 
3. Object.observe (基本上已经废弃) 
4. MutationObserver 

运⾏过程 

线程都有⾃⼰的运⾏数据存储空间，堆的空间⽐较⼤，所以存储⼀些对象； 

栈的空间⽐较⼩，所以存储⼀些基础数据类型、对象的引⽤，函数的调⽤； 

函数调⽤就⼊栈，执⾏完函数体的代码⾃动从栈中弹出——调⽤栈。 当栈中的函数出栈时，栈为空的话，我们会调⽤⼀些异步函数，这个异步函数会找它们的异 步处理模块，异步处理模块包括定时器、promise、Ajax等，异步处理模块会找它们各⾃对 应的线程，线程向任务队列中添加事件，再从任务队列中取出事件，去执⾏对应的回调。 

3个注意点： 

1. 整个script代码块属于宏任务 
2. 当宏任务执⾏完，会去执⾏所有微任务 
3. 微任务执⾏完再去执⾏下⼀个宏任务，等调⽤栈为空时执⾏⼀个微任务；调⽤栈不 为空时，任务队列的微任务⼀直等待；微任务执⾏完又去取任务队列的宏任务，依 次执⾏宏任务，执⾏宏任务时检查当前是否存在微任务，若有微任务就去 执⾏完 所有微任务，然后 再去执⾏后续的宏任务 。 

注意点： 

1. ⼀个 Event Loop 有⼀个或多个 task queue（任务队列） 
2.  每个 Event Loop 有⼀个 microtask queue（微任务队列） 
3. requestAnimationFrame 不在任务队列也不在为任务队列，在渲染阶段执⾏ 
4. 任务需要多次事件循环才能执⾏完，微任务是⼀次性执⾏完 
5. 主程序和 setTimeout 都是宏任务，⼀个 promise 是微任务，第⼀个宏任务（主程 序）执⾏完，执⾏全部的微任务（⼀个 promise），再执⾏下⼀个宏任务 （setTimeout） 

记住⼀点，要把本次宏任务下所产⽣的微任务全部执⾏完才会执⾏下⼀个宏任务，记住是产 ⽣的，没有产⽣的不会执⾏！ 

所谓⼀轮事件循环就是第⼀轮宏任务和微任务结束。当微任务队列清空后,⼀个事件循环结 束。 所以正确的⼀次 Event loop 顺序是： 

1. 执⾏同步代码，这属于宏任务 
2. 执⾏栈为空，查询是否有微任务需要执⾏ 
3. 执⾏所有微任务 
4. 必要的话渲染 UI 
5. 然后开始下⼀轮 Event loop，执⾏宏任务中的异步代码 

通过上述的 Event loop 顺序可知，如果宏任务中的异步代码有⼤量的计算并且需要操作 DOM 的话，为了更快的 界⾯响应，我们可以把操作 DOM 放⼊微任务中。

####  Node事件循环



JSONP, postMessage, cors, nginx, websocket, 





### 前端安全

XSS 跨站脚本攻击

CSP

HttpOnly

CSRF

SQL注入攻击

DDos

DNS劫持

JSON劫持

HTTPS中间人攻击





### 性能优化

1. ⽹站打开速度 
2. 动画流畅 
3. 表单提交速度 
4. 列表滚动页⾯切换是否卡顿

优化⼿法 

1. 聚焦⽤户 
2. 尽快响应⽤户输⼊
3.  动画执⾏流畅
4. 最⼤化主线程空闲时间 
5. ⽹页可交互性

#### HTML 

1. 避免HTML中直接写CSS
1. viewport加速页⾯渲染 
1. 使⽤语义化标签
1. 减少标签的使⽤，DOM解析是⼀个⼤量遍历的过程 
1. 避免src和href空值 
1.  减少DNS查询数

#### CSS 

1. 避免后代选择符 
1. 避免链式~ 
1. 避免!important 
1. link代替@import

@import会将请求变得 串⾏化，导致加载增加延迟

1. 减少回流与重绘 
2. CSS 放在 head 中 
3.  压缩CSS 开启gzip压缩 
4. ⾻架屏+合理的loading 
5. 优化选择器路径，避免 过多嵌套 
6. 选择器合并：压缩空间和资源开销 
7. 精确样式

⽐如设置{padding-left:10px}的值，避免{padding:0 0 0 10px}这样的写法

1. 异步加载CSS 
2. 避免通配符

a .b *{} 像这样的选择器，从右到左解析，在解析过程中遇到通配符（**）会去遍历整个 dom

1. 少⽤float：渲染时计算量⼤ 
2. 0值不加单位：兼容性 
3. 避免使⽤ 昂贵 的属性

因为他们渲染成本挺⾼，渲染速度慢⼀些 

1. border-radius 
2. box-shadow 
3. opacity 
4. transform 
5. filter
6. position: fixed 
7. 使⽤先进布局⽅式——flex

会造成阻塞吗 1. CSS加载不会阻塞DOM树解析 2. CSS加载会阻塞DOM树渲染 3. CSS加载会阻塞后⾯JS执⾏



#### JS

1. 避免循环操作DOM  
2. 事件委托

绑定事件时，不绑定到⽬标元素上，⽽是绑定到其祖先元素上 

1. 监听事件少 
2. 新增节点时，⽆需增加事件绑定 
3. scrip标签放在body后

CSS放在 

因为JS阻塞DOM的构建(因为DOM解析遇到JS会停⽌解析，开始下载脚本并执⾏) ，CSSOM 的构建阻塞JS执⾏ 

1. 压缩⽂件 
2. 按需加载 
3. 避免逐个操作DOM样式，尽可能预留好CSS样式，通过样式名的修改改变DOM样 式，集中式操作减少reflow的次数 
4. 减少iframe数量

合成 

1. 合成层的位图 交由GPU处理，⽐CPU块
2. repaint本⾝，不影响其它层 
3. transform和opacity不触发重绘

代码问题 

1. 频繁使⽤JSON.parse/JSON.stringify⼤对象 
2.  正则灾难性回溯
3. 内存泄漏

#### ⽹络相关 

DNS预解析 预先获得域名所对应的 IP，href的值是预解析的域名 

preload和prefetch 

preload强制浏览器⽴即获取资源， 具有较⾼优先级 

prefetch的资源获取时可选 和 较低 优先级的，是否获取取决于浏览器

缓存 

强缓存 协商缓存 

选择合适缓存策略 对于⼤部分的场景都可以使⽤强缓存配合协商缓存解决 

1. 使⽤ Cache-control: no-store ，表⽰该资源不需要缓存 
2. 使⽤ Cache-Control: no-cache 并配合 ETag ，表⽰该资源已被缓存，但是每次都 会发送请求询问资源是否更新 
3. 使⽤ Cache-Control: max-age=31536000 并配合策略缓存使⽤，对⽂件进⾏指纹 处理，⼀旦⽂件名变动就会⽴刻下载新的⽂件

使⽤HTTP2.0 

1. 解析速度快 
2. 头部压缩 
3. 多路复⽤ 
4. 服务器推送 
5. 浏览器由并发请求限制 

预加载 1. 有些资源不需要马上⽤到，但希望尽早获取 2. 预加载强制请求资源，不会阻塞 onload 事件

预渲染 

将下载的⽂件预先在后台渲染 预渲染可以提⾼页⾯的加载速度，但是要确保该页⾯百分百会被⽤户，否则⽩⽩浪费资源 

减少HTTP请求 使⽤服务端渲染 SSR （service side render） Gzip压缩 避免重定向

渲染优化 

懒执⾏ 

将某些逻辑延迟到使⽤时再计算。该技术可以⽤于⾸屏优化，对于某些耗时逻辑并不需要在 ⾸屏就使⽤的，就可以使⽤懒执⾏。懒执⾏需要唤醒，⼀般可以通过定时器或者事件的调⽤ 来唤醒。 

懒加载 

将不关键的资源延后加载——尽量只加载⽤户正 浏览 或即将会 浏览的图⽚ 只加载⾃定义区域（通常是可视区域，但也可以是即将进⼊可视区域）内需要加载的东西 

对于图⽚来说，先设置图⽚标签的 src 属性为⼀张占位图，真实的图⽚资源放⼊⾃定义属性 data-src 中，当进⼊⾃定义区域时，就将⾃定义属性替换为 src 属性，这样就会下载图⽚资 源

节流防抖 

防抖：单位时间内多次触发，只执⾏最后的那⼀次，原理：延迟执⾏，期间但凡有新的触发 就重置定时器 

节流：单位时间只触发⼀次，原理：上锁，只有满⾜⼀定间隔时间才能执⾏

图⽚

合适图⽚格式 

1. WebP 格式具有更好的图像数据压缩算法，更⼩的图⽚体积，拥有⾁眼识别⽆差异 的图像质量，缺点是兼容性并不好 
2. ⼩图使⽤ PNG，对于⼤部分图标，完全可以使⽤ SVG 代替 
3. 照⽚使⽤ JPEG 
4. 雪碧图( 将多个图标⽂件整合到⼀张图⽚中 )

可能请求⾮常多的⼩图⽚，会受到浏览器并发 HTTP 请求数的限制 

1. 图⽚压缩 
2. 不⽤图⽚，⽤CSS代替 
3.  对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪费带宽。⼀般图 ⽚都⽤ CDN 加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图⽚

1. JPEG/JPG ⾼质量 有损压缩，体积⼩，不⽀持透明 2. 应⽤于轮播图 ⼤的背景图、banner 
2. PNG 1. ⽆损压缩，质量好，体积⼤，⽀持透明 2. 应⽤⼩的logo 
3. SVG 1. 体积⼩，不失真，兼容好 2. 应⽤于图标 
4. GIF 1. ⽀持透明 
5. Webp 有损压缩与⽆损压缩（可逆压缩）的图⽚⽂件格式 ⽐PNG/JPEG格式⼩ ⽀持透明度 体积和效果上都做的不错

webpack压缩 

配置 image-webpack-loader 

雪碧图 

CSS Sprites ，精灵图，图像合成技术，主要⽤于⼩图⽚显⽰ 

同原域名请求有最⼤并发限制，Chrome为6个，如 页⾯有10个⼩图，需要10次请求，2次并 发 

若把10个图合成⼀个⼤图，只需1次请求 1. 减少请求次数 2. 减少服务器压⼒ 3. 减少并发 4. 提⾼加载速度 5. 减少⿏标滑过的⼀些bug 6. 解决⽹页设计师在图⽚命名上的困扰

iconfont 

通过字体⽅式展⽰图标，⽤户 图标渲染、简单图形、特殊字体等 1. 轻量，已修改 2. 减少请求次数

内联Base 64

图⽚转为base64串，解析图⽚不会请求下载，⽽是解析字符串 

缺点 1. ⽐使⽤⼆进制体积增⼤ 33% 2. 全部内联后，原本可并⾏加载的图⽚会串⾏放⼊请求 适⽤于 更新频率低、⾸屏或⾻架图上的⼩图标

CSS代替图 实现修饰效果，半透明、阴影、圆⾓、渐变等

CDN图⽚ 

图⽚懒加载 

暂时不设置图⽚的src属性，先卸载data-src中，等图⽚到了可视区域再将真实src放进src属 性 使⽤background-url，应⽤到具体元素时，才会下载图⽚ 

图⽚预加载 需要展⽰⼤量图，将图提前加载到本地缓存 

响应式图加载 在不同分辨率的设备上显⽰不同尺⼨的图 

其他⽂件优化 1. 服务端开启⽂件压缩功能 2. 执⾏ JS 代码过长会卡住渲染，对于需要很多时间计算的代码可以使⽤ Webworker webWorker是运⾏在后台的JS，另开⼀个⼦线程，不会影响性能

CDN 

内容分发⽹络 静态资源使⽤ CDN 加载，由于浏览器对于单个域名有并发请求上限，可以考虑使⽤多个 CDN 域名 

使⽤ Webpack 优化 1. 对于 Webpack，打包项⽬使⽤ production 模式，会⾃动开启代码压缩 2. ES6 模块开启 tree shaking，移除没有使⽤的代码 3. 优化图⽚，对于⼩图使⽤ base64 的⽅式写⼊⽂件 4. 按照路由拆分代码，实现按需加载 5. 给打包出来的⽂件名添加哈希，实现浏览器缓存⽂件 

监控 采集——>上传——>分析——>报警 渲染⼏万条数据不卡? 通过 requestAnimationFrame 来每 16 ms 刷新⼀次。

#### SPA首屏优化

浏览器从响应⽤户输⼊⽹址地址，到⾸屏内容渲染完成时间，整个⽹页不⼀定要完全渲染完 成，但需要展⽰当前视窗内容 

加载慢的原因 

1. ⽹络延时 
2. 资源⽂件体积过⼤ 
3. 资源加载重复发送请求 
4.  加载脚本时，渲染内容阻塞 

解决 

1. 减少⼊⼜⽂件体积 
2. 静态资源本地缓存 
3. UI框架按需加载 
4. 图⽚资源压缩 
5.  组件重复打包
6. 开启GZip压缩 
7. 使⽤SSR

减少⼊⼜⽂件体积 

路由懒加载，将不同路由对应组件分割成不同代码块，待路由被请求时单独打包路由，使得 ⼊⼜⽂件变⼩ 

以函数形式动态加载路由，可以把各⾃的路由⽂件分别打包，只在解析给定路由时，才会加 载路由组件 

静态资源本地缓存 HTTP缓存和localStorage 

按需加载 对UI库按需引⽤

图⽚资源压缩 

对icon，使⽤在线字体图标 

组件重复打包 若A.js是⼀个常⽤库，多个路由使⽤它会造成重复下载 在webpack的config中，修改CommonChunkPlugin的配置 minChunks为3表⽰会把使⽤3次及以上的包抽离，放进公共依赖⽂件

使⽤SSR 服务端渲染，Server Side ，组件或页⾯通过服务器⽣成html字符串，发送到浏览器

降低APP⾸页开屏渲染时间 

1. ⼆次启动时先利⽤缓存渲染，后台进⾏异步数据更新 
2. 减少不必要的请求 和数据获取 
3. 提前请求或减少http请求 
4. 优化图⽚⽂件尺⼨，压缩图⽚格式，压缩代码 
5. 启⽤gzip 压缩功能 
6. 使⽤CDN 
7. ⽹址后⾯加上“/”:对服务器⽽⾔，不加斜杠服务器会多⼀次判断的过程，加斜杠就 会直接返回⽹站设置的存放在⽹站根⽬录下的默认页⾯。 
8. Ajax采⽤缓存调⽤

页⾯⽩屏 

⽹络请求，返回状态 组件样式布局，组价未显⽰ 

⽹页卡顿原因 

1. ⽹络请求是否过多，导致数据传输变慢，可通过缓存优化 
2. 资源bundle太⼤，考虑拆分 
3. 代码是否有太多循环在主线程上花费太长时间 
4. 浏览器某个帧 中 渲染太多东西 
5. 页⾯渲染时，⼤量回流和重绘
6. 内存泄露

动画性能优化 

1. 合理布局 2. transform代替left、top 减少重排 3. 硬件加速 4. 避免不必要的图形层 5. requestAnimationFrame实现动画 动画每⼀帧都是re-render，显⽰器刷新频率 60 HZ，意味着每⼀帧任务耗时不超过 16ms



### AST抽象语法树

词法分析

语法分析



### 编译

编译器，解释器

编译步骤：

1. 分词 / 词法分析 a. 把字符组成的字符串分解成有意义的代码块（词法单元）， 如 var a = 2，会分 解为 var ， a， =，2； 
2. 解析 / 语法分析 a. 将上⾯的词法单元流（数组）转换为由元素逐级嵌套所组成的代表程序语法结构 的树，也就是AST 
3. ⽣成抽象语法树（AST） 
4. 词义分析 
5. ⽣成⼆进制⽂件或者字节码 
6. 执⾏

我们前端开发⽤的JavaScript就是解释型语⾔，其实⼀开始是没有字节码的，是直接将AST 编译成机器码，所以效率是很⾼的，但是机器码占⽤的内存过⼤，所以又有了字节码的出 现。这⾥又涉及到⼀门新的技术 JIT （即使编译）的出现。 所以我们的V8引擎使⽤的是 字节码 + JIT 的技术



### 鉴权

Cookie 

服务端响应客户端请求时，会返回⼀个cookie，后续客户端的请求携带这个cookie 

特点 1. 存储在客户端，可随意纂改 2. 影响性能，最⼤为4kb 3. ⼀个浏览器对于⼀个⽹站只能存不超过20个Cookie，⽽浏览器⼀般只允许存放300 个Cookie 4. 移动端对Cookie⽀持不友好 5. ⼀般情况下存储的是纯⽂本，对象需要序列化之后才可以存储，解析需要反序列化 

通过设置正确的domain和path，减少数据传输，节省带宽 

Cookie-session 

cookie需要的存的东西越来越多，但是cookie⼤⼩有限制 所以后端返回sessionId，客户端将sessionid存在cookie中 缓存数据库：所有机器根据sessionId去缓存系统获取⽤户信息和认证 

局限性 1. 依赖Cookie，但Cookie可被禁⽤ 2. 系统不停请求缓存服务器查找信息，内存开销增加 3. 存在单点登录失败的可能性 若负责session的机器挂了，整个登录就挂了，但项⽬中，负责session的机器也是有 多台机器的集群进⾏负载均衡增加可靠性 

SSO 

（单点登录）三种类型 Single Sign On 在多个应⽤系统中，只需要登录⼀次，就可以访问其他相互信任的应⽤系统 

单点登录 1. 同⼀站点下 2. 相同的顶级域名 3. 不同的顶级域名 

相同域名和相同顶级域名下可共享cookie 

但是不同域呢？ CAS（中央认证服务）原理 流程和Cookie-session模式相同 

Json Web Token 

最简单的token组成:uid(⽤户唯⼀的⾝份标识)、time(当前时间的时间戳)、sign(签 名，由token的前⼏位+哈希算法压缩成⼀定长的⼗六进制字符串，防⽌恶意三⽅拼 接token请求) 

JWT由header（头部）、payload（负载）、signature（签名）这三个部分组成，中间⽤.来 分隔开：Header.Payload.Signature jwt: 

弊端 1. JWT的退出是假的登录失效，只要之前的token没过期依然可以⽤ 2. 安全性依赖密钥 3. 加密⽣成的数据长 

优点 1. 不依赖Cookie 2. 没有单点登录的cookie-sessionId模式好扩展 3. 服务器保持⽆状态性 

session 和 token 的对⽐就是「⽤不⽤cookie」和「后端存不存」的对⽐

### Service Worker

Service workers 本质上充当 Web 应⽤程序与浏览器之间的代理服务器，也可以在⽹ 络可⽤时作为浏览器和⽹络间的代理。旨在创建有效的离线体验，拦截⽹络请求并 基于⽹络是否可⽤，以及更新的资源是否驻留，在服务器上来采取适当的动作。还 允许访问推送通知和后台同步 API。 

运⾏在浏览器背后的独⽴线程， 通常⽤来做缓存⽂件，提⾼⾸屏速度 。 不仅仅是cache，还通过worker的⽅式进⼀步优化，基于H5的web worker，所以不会阻塞当 前JS线程的执⾏。 

SW最重要的是 1. 后台线程：独⽴于当前⽹络线程 2. ⽹络代理：在⽹页发起请求时代理，缓存⽂件 

使⽤Service Worker的话，传输协议必须是HTTPS。因为Service Worker中涉及到请求拦 截，所以必须使⽤HTTPS协议保障安全。它可以让我们⾃由控制缓存哪些⽂件、如何匹配 缓存、如何读取缓存，并且缓存是持续性的。 

Service Worker 实现缓存功能⼀般分为三个步骤：⾸先需要先注册 Service Worker，然后监 听到 install 事件以后就可以缓存需要的⽂件，那么在下次⽤户访问的时候就可以通过拦截 请求的⽅式查询是否存在缓存，存在缓存的话就可以直接读取缓存⽂件，否则就去请求数 据。 

当 Service Worker 没有命中缓存的时候，我们需要去调⽤ fetch 函数获取数据。也就是说， 如果我们没有在 Service Worker 命中缓存的话，会根据缓存查找优先级去查找数据。但是 不管我们是从 Memory Cache 中还是从⽹络请求中获取的数据，浏览器都会显⽰我们是从 Service Worker中获取的内容。



### Webstorage

克服cookie带来的限制，不需要持续将数据返回server。 1. 提供cookie之外的存储会话数据的路径 2. 可以⽤来跨⽹站/应⽤ 检测⽤户的⾏为⽽不需要服务端脚本和数据库 3. 拥有在⽤户即使突然断⽹的情况下保存部分web应⽤的能⼒，不会让你因为⽹络连 接问题受到影响 4. 和cookie⼀样存在跨域策略 分类 localStorage

#### localStorage

(针对同⼀个域名) 

特点： 1. ⽣命周期：持久化的本地存储，除⾮⼿动删除数据，否则数据是永远不会过期的 2. 存储的信息在同⼀域中共享 3. ⼤⼩：5M，和浏览器⼚商有关 4. 本质上是对字符串的读取，若存储内容过多会消耗内存空间，导致页⾯卡顿 5. 受同源策略限制 

缺点 1.⽆法像cookie⼀样设置过期时间 2.只能存⼊字符串，⽆法直接存储对象

#### sessionStorage

和localStorage相似，唯⼀不同就是⽣命周期，⼀旦页⾯关闭，sessionStorage将会删除数 据 

相同点 1. 存储⼤⼩：⼀般都是5MB 2. 存储位置：都存在客户端 3. 存储内容类型：只能存储字符串类型 4. 获取⽅式：window.localStorage 5. 应⽤：localStorage⽤于长期登录，适合长期保存在本地的数据。sessionStorage ⽤于敏感账号⼀次性登录。 6. 接⼜封装 

优点 1. 存储空间⼤ 2. 节省⽹络流量 3. 快速显⽰ 4. 安全性 5. 对于那种只需要短暂存储关闭页⾯就可以丢弃的数据，sessionStorage很好⽤

#### IndexedDB

Indexed Database API（IndexedDB） 

前端数据库有WebSql和IndexDB，其中WebSql被规范废弃，他们都有⼤约50MB的最⼤容 量，可以理解为localStorage的加强版。 扩展的前端存储⽅式，是运⾏在浏览器中的⾮关系型数据库，理论上容量⽆上限。

 特性 1. 储存量理论上没有上限 2. 所有操作都是异步的，相⽐ LocalStorage 同步操作性能更⾼，尤其是数据量较⼤ 时 3. 原⽣⽀持储存JS的对象 4. 是个正经的数据库，意味着数据库能⼲的事它都能⼲ 5. 同源策略限制 6. 操作繁琐



### Cookie

调⽤ Cookie 时，由于可校验 Cookie 的有效期，以及发送⽅的域、路径、协议等信息，所 以正规发布的 Cookie 内的数据不会因来⾃其他Web 站点和攻击者的攻击⽽泄露 

Set-Cookie 当服务器准备开始管理客户端的状态时，会事先告知各种信息。 

```js
Set-Cookie: status=enable; expires=Tue, 05 Jul 2011 07:26:31 GMT; path
```

cookie字段 

`name = value` 如果⽤于保存⽤户登录态，赋值 cookie 的名称和值 

`expires=datecookie`有效期

`path=path`将服务器上的⽂件⽬录作为cookie的使⽤对 象

`domain=域名`cookie适⽤对象的域名

`HttpOnly`不能通过 JS 访问 Cookie，减少 XSS 攻击

`secure`只能在协议为 HTTPS 的请求中携带

`same-site`规定浏览器不能在跨 域请求中携带 Cookie，减少 CSRF 攻击 

`expires` 指定 Cookie 的有效期。省略 expires 属性时，其有效期仅限于维持浏览器会话（Session） 时间段内 

`domain` 表⽰cookie作⽤域 ⽐如，当指定 .example.com 后，除 .example.com 以外， www.example.com或 www2.example.com等⼦域名都可以访问Cookie 

`secure` 限制 Web 页⾯仅在 HTTPS 安全连接时，才可以发送 Cookie 

`Set-Cookie: name=value; secure` 以上例⼦仅当在https://www.example.com/（HTTPS）安全连接的情况下才会进⾏Cookie 的回收 当省略 secure 属性时，不论 HTTP还是 HTTPS，都会对 Cookie 进⾏回收 

`HttpOnly` 禁⽌JS脚本访问 Cookie Set-Cookie: name=value; HttpOnly 使⽤ JavaScript 的 document.cookie ⽆法读取Cookie的内容。 因此，也就⽆法在 XSS 中利 ⽤ JavaScript 劫持Cookie 

`SameSite` 是否允许跨域时携带Cookie strict：任何情况都不允许作为第三⽅cookie Lax：宽松模式，只能在请求⽅法为Get且请求改变了当前页⾯或打开新的页⾯时，允许 cookie跨域访问 None：默认模式，请求⾃动携带cookie 

Cookie 请求⾸部字段 告知服务器，当客户端想获得 HTTP状态管理⽀持时， 就会在请求中包含从服务器接收到 的 Cookie。 接收到多个Cookie 时，同样可以以多个 Cookie形式发送。 Cookie: status=enable 禁⽌js访问cookie 设置HttpOnly JS Document.cookieAPI ⽆法访问cookie JS设置cookie document.cookie 属性来创建 、读取、及删除 cookie 创建 cookie ： document.cookie="username=John Doe"; 添加⼀个过期时间（默认cookie 在浏览器关闭时删除： document.cookie="username=John Doe; expires=Thu, 18 Dec 2043 12:00:00 GMT"; 使⽤ path 参数告诉浏览器 cookie 的路径。默认，cookie 属于当前页⾯ document.cookie="username=John Doe; expires=Thu, 18 Dec 2043 12:00:00 GMT; path=/"; 读取 var x= document.cookie; //以字符串⽅式返回所有cookie 

cookie作⽤域 domain本⾝以及domain下的所有⼦域名 跨域请求访问cookie 1. cookie不能跨根域，但JS可以，JS可以将cookie传给另外的域再保存⼀次域名 cookie，这样可能存在不同的cookie域包含同⼀个cookie值 2. browser不允许跨根域读写 3. 采⽤SSO单点登录⽅式 

没有cookie会出现什么问题？ 

cookie：解决 如何记录客户端⽤户信息 的问题。保存在本地的⼀部分数据，再次发送请求 被携带传送到服务器，通知server是否请求来⾃统⼀状态浏览器，如保持⽤户登录 使基于⽆HTTP协议记录的信息状态稳定成为可能 

作⽤： 1. 会话状态 2. 个性化设置 3. 浏览器⾏为跟踪



### 缓存

+ HTTP缓存：强缓存、协商缓存
+ 浏览器缓存：storage 前端数据库和应⽤缓存

应用缓存已废弃

强缓存 

服务器与浏览器约定⼀个⽂件过期时间，向browser缓存查找该请求结果，并根据该结果的 缓存规则决定是否使⽤该结果。决定是否使⽤缓存主动性在浏览器这边. 

强制缓存失效，发送请求（和第⼀次请求⼀样），响应状态码为200 

存在缓存结果和标识但结果已失效，使⽤协商缓存 

存在缓存结果和标识且未失效，直接返回结果，响应状态码为403，在 size 项中 标识的是 from disk cache 

发送请求时，服务器会把缓存规则放⼊HTTP响应报⽂的HTTP头中和请求结果⼀起返回给 浏览器， 控制强制缓存的字段分别是Expires（HTTP1.0时期使⽤）



Cache-Control(HTTP/1.1) 

来源于响应头和请求头。 

没有采⽤具体的过期时间节点的⽅式，⽽是采⽤过期时长控制缓存，对应缓存为max-age。 在HTTP/1.1中，Cache-Control是最重要的规则，主要⽤于控制⽹页缓存，主要取值为： 

+ public：所有内容都将被缓存（客户端和代理服务器都可缓存） 
+ private：所有内容只有客户端可以缓存，Cache-Control的默认取值 

+ no-cache：跳过当前当前强缓存，客户端缓存内容，直接进⼊协商缓存阶段。 

+ no-store：所有内容都不会被缓存，即不使⽤强制缓存，也不使⽤协商缓存 

+ max-age=xxx (xxx is numeric)：缓存内容将在xxx秒后失效，只有http1.1可⽤。

强缓存失效进⼊协商缓存。 

Cache-Control实现流程: 

1. 浏览器第⼀次请求访问服务器资源时,服务器会在返回这个资源的同时,在response 头部加上 Cache-Control, Cache-Control 中设置了过期时间⼤⼩； 
2. 浏览器再次访问服务器该资源时,会先通过请求资源的时间与cache-control中设置 的过期时间对⽐,计算该资源是否过期,若没有则使⽤该缓存,否则重新请求资源. 
3. 服务器再次收到请求后,会再次更新Response头部的Cache-Control. 

优先级:Cache-Control > Expires

协商缓存

协商缓存就是与服务端协商之后，通过协商结果来判断是否使⽤本地缓存，通过服 务端告知客户端是否可以使⽤缓存的⽅式称为协商缓存

强制缓存失效后，browser携带缓存标识tag向server发请求，由服务器根据缓存tag决定是 否使⽤缓存的过程。

tag分为两种：Last-Modified和ETag，不分上下。

Last-Modified(HTTP/1.0) Last-Modified(响应头)，If-Modified-Since(请求头)

最后⼀次修改时间。以此判断当前请求资源是否是最新的，浏览器第⼀次给服务器发送请求 后，服务器会在响应头中加⼊这个字段。 

browser接收后，若再次请求，会在请求头中携带If-Modified-Since字段，也就是server传 来的最后修改时间。 

服务器拿到请求头中的If-Modified-Since字段后，和服务器中该资源的最后修改时间对⽐：

若请求头中这个值⼩于修改时间，说明应该更新了。返回新的资源，状态码为200。 否则返回304，直接使⽤缓存。

ETag(HTTP/1.1) 

服务器根据当前⽂件的内容，给⽂件页⾯⽣成的唯⼀标识。通过响应头传送给浏览器。 浏览器会在下次请求时，将这个值作为If-None-Match字段的内容，放到请求头。 使⽤ ETag 字段实现的协商缓存的过程如下

+ 当浏览器第⼀次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 ETag 唯⼀标识，这个唯⼀标识的值是根据当前请求的资源⽣ 成的； 
+ 当浏览器再次请求访问服务器中的该资源时，⾸先会先检查强制缓存是否过期，如 果没有过期，则直接使⽤本地缓存；如果缓存过期了，会在 Request 头部加上 IfNone-Match 字段，该字段的值就是 ETag 唯⼀标识；
+  服务器再次收到请求后，会根据请求中的 If-None-Match 值与当前请求的资源⽣ 成的唯⼀标识进⾏⽐较： 
+ 如果值相等，则返回 304 Not Modified，不会返回资源； 如果不相等，则返回 200 状态码和返回资源，并在 Response 头部加上新的 ETag 唯⼀标识； 
+ 如果浏览器收到 304 的请求响应状态码，则会从本地缓存中加载资源，否则更新 资源。

ETag(响应头)、If-None-Match(请求头)

强ETab 

强ETag值，不论实体发⽣多么细微的变化都会改变其值。 

弱ETag 

弱ETag值只⽤于提⽰资源是否相同。只有资源发⽣了根本改变，产⽣差异时才会改变ETag 值。这时，会在字段值最开始处附加W/，'W/' （区分⼤⼩写）开头表⽰使⽤弱校验。 对于两个资源，强校验要求每个字节都相同才认为是同⼀个资源；⽽弱校验则把决定权交给 开发者，根据需要区分的要素来⽣成相应的 ETag 。 

为什么要区分强弱呢，因为⼤多数情况下，确保严格的字节级别的⼀致性是没有必要的。例 如，如果我们开启了 HTTP 压缩，那么对于⼀个资源的响应，压缩前和压缩后的字节就是 不⼀致的，但通常我们只关⼼压缩前的 ETag ，这时就需要使⽤弱校验的 ETag 。

两者对⽐

 如果 HTTP 响应头部同时有 Etag 和 Last-Modified 字段的时候， Etag 的优先级更⾼，也就 是先会判断 Etag 是否变化了，如果 Etag 没有变化，然后再看 Last-Modified。 

1. 精确度：ETag>Last*Modified。ETag按照内容给资源上标识，可准确感知资源的 变化。Last*Modified不⼀样 编辑了资源⽂件，但内容没改变，会造成缓存失效 Last_Modified可感知的时间单位是s，若在1s内修改了⽂件，不能体现出来。 
2. 性能上：LastModified优于Etag。LastModified只是记录⼀个时间点，ETag根据⽂ 件具体内容⽣成哈希值。

协商缓存这两个字段都需要配合强制缓存中 Cache-control 字段来使⽤，只有在未能命中 强制缓存的时候，才能发起带有协商缓存字段的请求。

缓存存储 

+ 内存缓存：快速读取和实效性 

+ 硬盘缓存：写⼊硬盘⽂件，需要I/O操作，重新解析改缓存内容，读取复杂，速度 慢 

浏览器中的缓存位置⼀共有四种，按优先级从⾼到低排列分别是： Service Worker ，Memory Cache， Disk Cache ，Push Cache 

⼤的JS 、CSS⽂件直接丢进磁盘，反之丢进内存 内存使⽤率⾼时，⽂件优先进⼊磁盘



### 前端路由

#### hash模式

hash的变化不会刷新页⾯，也 不会发送给服务器。但hash的变化会被浏览器记录下来，来指导浏览器中的前进和后退，window.location.hash变化触发窗⼜onhashchange事件，监听hash变化。

#### history模式

H5新特性，允许直接修改前端路由，更新URL但不重新发请求，history可⾃定义地址。 window.history属性指向 History 对象，表⽰当前窗⼜的浏览历史，保存了当前窗⼜访问 过的所有页⾯⽹址。由于安全原因，浏览器不允许脚本读取这些地址，但允许在地址间导航。

back，forward，go，

pushState：在浏览记录中添加一个新纪录，不刷新页面。

replaceState：

popstate：历史记录变化时触发



### 输入URL回车后

简易版 

1. URL解析 
2. 查找缓存 
3. 域名解析：浏览器缓存>系统缓存>本地hosts>根域名>顶级域名>⼆级域名>三级域 名 
4. TCP三次握⼿
5. 发送HTTP请求
6. 服务器处理请求并返回报⽂ 
7. 浏览器解析渲染页⾯ 
8. TCP四次挥⼿ 关闭TCP连接

#### 导航阶段

##### 浏览器主进程

**1.⽤户输⼊URL**

1. 浏览器进程检查url，组装协议，构成完整的url，这时候有两种情况： 输⼊的是搜索内容：地址栏会使⽤浏览器默认的搜索引擎，来合成新的带搜索关键 字的URL。 输⼊的是请求URL：地址栏会根据规则，给这段内容加上协议，合成为完整的 URL；
2. 浏览器进程通过进程间通信（IPC）把url请求发送给⽹络进程；

URL⼀般包括⼏⼤部分： 

protocol，协议头，譬如有http，ftp等 

host，主机域名或IP地址 

port，端⼜号 

path，⽬录路径 

query，即查询参数 

fragment，即 #后的hash值，⼀般⽤来定位到某个位置

##### 网络进程

**2.URL请求过程**

**3.⽹络进程接收到url请求后检查本地是否缓存了该请求资源。 **

+ 浏览器发送请求前，根据请求头的expires和cache-control判断是否命中（包括是 否过期）强缓存策略，如果命中，直接从缓存获取资源，并不会发送请求。如果没 有命中，则进⼊下⼀步。 

+ 没有命中强缓存规则，浏览器会发送请求，根据请求头的If-ModifiedSince(last_modified)和If-None-Match(ETag)判断是否命中协商缓存，如果命中， 直接从缓存获取资源。如果没有命中，则进⼊下⼀步。
+ 如果前两步都没有命中，则直接从服务端获取资源。

**4.准备IP地址和端⼜**：进⾏DNS解析时先查找缓存，没有再使⽤DNS服务器解析，查找顺 序为：

浏览器缓存； 

本机缓存； 

hosts⽂件； 

路由器缓存； 

ISP DNS缓存； 

DNS递归查询（本地DNS服务器 -> 权限DNS服务器 -> 顶级DNS服务器 -> 13台根 DNS服务器）

**5、等待TCP队列**：浏览器会为每个域名最多维护6个TCP连接，如果发起⼀个HTTP请求 时，这 6个 TCP连接都处于忙碌状态，那么这个请求就会处于排队状态，解决⽅案： 

+ 采⽤域名分⽚技术：将⼀个站点的资源放在多个（CDN）域名下⾯。 
+ 升级为HTTP2，就没有6个TCP连接的限制了；

**6、通过三次握⼿建⽴TCP连接**： 

第⼀次：客户端先向服务器端发送⼀个同步数据包，报⽂的TCP⾸部中：标志位： 同步SYN为1，表⽰这是⼀个请求建⽴连接的数据包；序号Seq=x，x为所传送数据 的第⼀个字节的序号，随后进⼊SYN-SENT状态；

标志位值为1表⽰该标志位有效。

第⼆次：服务器根据收到数据包的SYN标志位判断为建⽴连接的请求，随后返回⼀ 个确认数据包，其中标志位SYN=1，ACK=1，序号seq=y，确认号ack=x + 1表⽰收 到了客户端传输过来的x字节数据，并希望下次从x+1个字节开始传，并进⼊SYNRCVD状态；

这⾥要区分标志位ACK和确认号ack；

第三次：客户端收到后，再给服务器发送⼀个确认数据包，标志位ACK=1，序号 seq=x+1，确认号ack=y+1，随后进⼊ESTABLISHED状态；

服务器端收到后，也进⼊ESTABLISHED状态，由此成功建⽴了TCP连接，可以开始数据传 送； 

为什么要第三次挥⼿？避免服务器等待造成资源浪费，具体原因： 

如果没有最后⼀个数据包确认（第三次握⼿），A先发出⼀个建⽴连接的请求数据 包，由于⽹络原因绕远路了。A经过设定的超时时间后还未收到B的确认数据包。 于是发出第⼆个建⽴连接的请求数据包，这次⽹路通畅，B的确认数据包也很快就到 达A。于是A与B开始传输数据； 过了⼀会A第⼀次发出的建⽴连接的请求数据包到达了B，B以为是再次建⽴连接， 所以又发出⼀个确认数据包。由于A已经收到了⼀个确认数据包，所以会忽略B发来 的第⼆个确认数据包，但是B发出确认数据包之后就要⼀直等待A的回复，⽽A永远 也不会回复。 由此造成服务器资源浪费，这种情况多了B计算机可能就停⽌响应了。

**7、构建并发送HTTP请求信息**；

+ 建⽴TCP连接后，在这基础上进⾏通信，浏览器发送http请求到⽬标服务器，请求 的内容包括 请求⾏ 请求头和请求体 
+ 当服务器接收到浏览器的请求之后，就会进⾏逻辑操作，处理完之后返回⼀个 HTTP响应消息，包括，响应⾏，响应头和响应体。 
+ 服务器响应之后，现在HTTP默认开启长连接，页⾯关闭后，TCP连接会经过四次 挥⼿断开

**8、服务器端处理请求**；

**9、客户端处理响应，⾸先检查服务器响应报⽂的状态码**：

+ 如果是301/302表⽰服务器已更换域名需要重定向，这时⽹络进程会从响应头的 Location字段⾥⾯读取重定向的地址，然后再发起新的HTTP或者HTTPS请求，跳 回第4步。
+  如果是200，就检查Content-Type字段，值为text/html说明是HTML⽂档，是 application/octet-stream说明是⽂件下载；

**10、请求结束**，当通⽤⾸部字段Conection不是Keep-Alive时，即不为TCP长连接时，通过 四次挥⼿断开TCP连接：

四次挥⼿步骤（抽象派） 

+ 主动⽅：我已经关闭了向你那边的主动通道了，只能被动接收了 
+ 被动⽅：收到通道关闭的信息 
+ 被动⽅：那我也告诉你，我这边向你的主动通道也关闭了 
+ 主动⽅：最后收到数据，之后双⽅⽆法通信 
+ 第⼀次：客户端（主动断开连接）发送数据包给服务器，其中标志位FIN=1，序号 位seq=u，并停⽌发送数据； 
+ 第⼆次：服务器收到数据包后，由于还需传输数据，⽆法⽴即关闭连接，先返回⼀ 个标志位ACK=1，序号seq=v，确认号ack=u+1的数据包； 
+ 第三次：服务器准备好断开连接后，返回⼀个数据包，其中标志位FIN=1，标志位 ACK=1，序号seq=w，确认号ack=u+1； 
+ 第四次：客户端收到数据包后，返回⼀个标志位ACK=1，序号seq=u+1，确认号 ack=w+1的数据包。

由于服务器不能马上断开连接，导致FIN释放连接报⽂与ACK确认接收报⽂需要分两次传 输，即第⼆次和第三次"挥⼿"；

##### 准备渲染进程

**11、准备渲染进程**：浏览器进程检查当前url是否与之前打开了渲染进程的页⾯的根域名相 同，如果相同，则复⽤原来的进程，如果不同，则开启新的渲染进程；

#####  提交⽂档

**12、提交⽂档**： 

+ 渲染进程准备好后，浏览器向渲染进程发起“提交⽂档”的消息，渲染进程接收到消 息后与⽹络进程建⽴传输数据的“管道” 
+ 渲染进程接收完数据后，向浏览器发送“确认提交” 
+ 浏览器进程接收到确认消息后更新浏览器界⾯状态：安全状态、地址栏url、前进 后退的历史状态、更新web页⾯

#### 渲染阶段

渲染步骤⼤致可以分为以下⼏步： 

1. 解析HTML，构建DOM树 
2. 解析CSS，⽣成CSS规则树 
3. 合并DOM树和CSS规则，⽣成render树 
4. 布局render树（Layout/reflow），负责各元素尺⼨、位置的计算 
5. 绘制render树（paint），绘制页⾯像素信息 
6. 浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显⽰在屏 幕上

在渲染阶段通过渲染流⽔线在渲染进程的主线程和合成线程配合下，完成页⾯的渲染；

##### 构建DOM树

**13、先将请求回来的数据解压，随后HTML解析器将其中的HTML字节流通过分词器拆分为 ⼀个个Token，然后⽣成节点Node，最后解析成浏览器识别的DOM树结构。**

1. ![image-20230318225435451](C:\Users\samue\AppData\Roaming\Typora\typora-user-images\image-20230318225435451.png)

2. 重点过程 
3. Conversion转换：浏览器将获得的HTML内容（Bytes）基于他的编码转换为单个 字符 
4. Tokenizing分词：浏览器按照HTML规范标准将这些字符转换为不同的标记 token。每个token都有⾃⼰独特的含义以及规则集 
5. Lexing词法分析：分词的结果是得到⼀堆的token，此时把他们转换为对象，这些 对象分别定义他们的属性和规则 
6. DOM构建：因为HTML标记定义的就是不同标签之间的关系，这个关系就像是⼀ 个树形结构⼀样。
7. 最后DOM树

渲染引擎还有⼀个安全检查模块叫 XSSAuditor，是⽤来检测词法安全的。在分词器 解析出来 Token 之后，它会检测这些模块是否安全，⽐如是否引⽤了外部脚本，是 否符合 CSP 规范，是否存在跨站点请求等。如果出现不符合规范的内容， XSSAuditor 会对该脚本或者下载任务进⾏拦截。

⾸次解析HTML时渲染进程会开启⼀个预解析线程，遇到HTML⽂档中内嵌的JavaScript和 CSS外部引⽤就会同步提前下载这些⽂件，下载时间以最后下载完的⽂件为准。

##### 构建CSSOM

**14、CSS解析器将CSS转换为浏览器能识别的styleSheets也就是CSSOM**：可以通过控制台输 ⼊document.styleSheets查看； 

这⾥要考虑⼀下阻塞的问题，由于JavaScript有修改CSS和HTML的能⼒，所以，需要先等到 CSS ⽂件下载完成并⽣成 CSSOM，然后再执⾏ JavaScript 脚本，最后再继续构建 DOM。 由于这种阻塞，导致了解析⽩屏；

优化⽅案： 

1. 移除js和css的⽂件下载：通过内联 JavaScript、内联 CSS； 
2. 尽量减少⽂件⼤⼩：如通过 webpack 等⼯具移除不必要的注释，并压缩 js ⽂件； 
3. 将不进⾏DOM操作或CSS样式修改的 JavaScript 标记上 async 或者 defer异步引 ⼊； 
4. 使⽤媒体查询属性：将⼤的CSS⽂件拆分成多个不同⽤途的 CSS ⽂件，只有在特定 的场景下才会加载特定的 CSS ⽂件。 可以通过浏览器调试⼯具的Network⾯板中的DOMContentLoaded查看最后⽣成DOM树所 需的时间；

可以通过浏览器调试⼯具的Network⾯板中的DOMContentLoaded查看最后⽣成DOM树所 需的时间；

##### 样式计算

**15、转换样式表中的属性值，使其标准化**。⽐如将em转换为px，color转换为rgb； 

**16、计算DOM树中每个节点的具体样式**，这⾥遵循CSS的继承和层叠规则；可以通过 Chrome调试⼯具的Elements选项的Computed查看某⼀标签的最终样式；

##### 布局阶段

 结合DOM和CSSOM树,⽣成渲染树 

**17、创建布局树**，遍历DOM树中的所有节点，去掉所有隐藏的节点（⽐如head，添加了 display:none的节点），只在布局树中保留可见的节点。 

**18、计算布局树中节点的坐标位置**（较复杂，这⾥不展开）,对于每个可见的节点,找到 CSSOM树中对应规则并应⽤,根据每个可见节点及其对应的样式,⽣成渲染树；

##### 分层

**19、对布局树进⾏分层，并⽣成分层树（Layer Tree）**，可以通过Chrome调试⼯具的Layer 选项查看。分层树中每⼀个节点都直接或间接的属于⼀个图层（如果⼀个节点没有对应的 层，那么这个节点就从属于⽗节点的图层）

图层 

⼀般来说，可以把普通⽂档流看成⼀个图层。特定的属性可以⽣成⼀个新的图层。不同的图 层渲染互不影响，所以对于某些频繁需要渲染的建议单独⽣成⼀个新图层，提⾼性能。但也 不能⽣成过多的图层，会引起反作⽤。

通过以下⼏个常⽤属性可以⽣成新图层 

+ 3D 变换：translate3d、translateZ 
+ will-change 
+ video、iframe 标签 
+ 通过动画实现的 opacity 动画转换 
+ position: fixed

##### 图层绘制

**20、为每个图层⽣成绘制列表（即绘制指令），并将其提交到合成线程**。以上操作都是在 渲染进程中的主线程中进⾏的，提交到合成线程后就不阻塞主线程了；

##### 切分图块

**21、合成线程将图层切分成⼤⼩固定的图块（256x256或者512x512）然后优先绘制靠近视 ⼜的图块，这样就可以⼤⼤加速页⾯的显⽰速度**； 

##### GPU 进程 

##### 栅格化操作 

**22.在光栅化线程池中将图块转换成位图，通常这个过程都会使⽤GPU来加速⽣成，使⽤ GPU⽣成位图的过程叫快速栅格化，或者GPU栅格化，⽣成的位图被保存在GPU内存中。**

##### 浏览器主进程 

##### 13. 合成与显⽰ 

**23、合成**：⼀旦所有图块都被光栅化，合成线程就会将它们合成为⼀张图⽚，并⽣成⼀个 绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。 

注意了：合成的过程是在渲染进程的合成线程中完成的，不会影响到渲染进程的主 线程执⾏； 

**24、显⽰**：浏览器进程⾥⾯有⼀个叫viz的组件，⽤来接收合成线程发过来的DrawQuad命 令，然后根据DrawQuad命令，将其页⾯内容绘制到内存中，最后再将内存显⽰在屏幕上。 将像素发送给GPU,展⽰在页⾯上(GPU将多个合成层合并成⼀个层,展⽰) 

到这⾥，经过这⼀系列的阶段，编写好的HTML、CSS、JavaScript等⽂件，经过浏览器就会 显⽰出漂亮的页⾯了。 

+ Layout回流 [重排]：通过 JavaScript 或者 CSS 修改元素⼏何位置属性，会触发重新 布局，解析后⾯⼀系列⼦阶段 
+ 重绘：跳过了布局阶段，直接进⼊绘制，然后再分块、⽣成位图及其以后⼦阶段； Painting 根据渲染树及回流得到的⼏何信息,得到节点的绝对像素. 
+ 合成：渲染引擎跳过布局和绘制阶段，执⾏的后续操作，发⽣在合成线程，⾮主线 程；



### Performance

前端性能监控

![image-20230401154839178](C:\Users\samue\AppData\Roaming\Typora\typora-user-images\image-20230401154839178.png)





### 常见状态码

`200` OK - [GET] : 服务器成功返回用户请求的数据

`201` CREATED - [POST/PUT/PATCH] : 用户新建或修改数据成功

`204` NO CONTENT - [DELETE] : 用户删除数据成功

`401` Unauthorized - [*] : 表示用户没有权限（令牌，用户名，密码错误）

`403` Forbidden - [*] : 表示用户得到授权但是访问是被禁止的

`404` NOT FOUND - [*] : 用户发出的请求针对的是不存在的记录，服务器没有进行操作
